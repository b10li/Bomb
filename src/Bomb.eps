import Header;
import Map;
import Player;
import Helpers;

const BombQ						= EUDArray(20);
var QIndex, QCount, boom;

const row						= Map.row;
const col						= Map.col;
const scale						= Map.scale;

const Computer					= Header.Computer;
const UnitID_Player 			= Header.UnitID_Player;
const UnitID_Bomb				= Header.UnitID_Bomb;
const UnitID_Fire				= Header.UnitID_Fire;
const UnitID_Wall				= Header.UnitID_Wall;
const UnitID_Box				= Header.UnitID_Box;
const DeadBox					= Header.DeadBox;
const ItemList					= Header.ItemList;

const loc2 = $L('loc2');
const loc3 = $L('loc3');
//-------------------------------------------------

function NewBomb(unitEpd)
{
	const x, y = Map.GetTileIndex(unitEpd);
	Map.SetMapXY(x, y, unitEpd);
}

function Push(unitEpd)
{
	BombQ[QIndex] = unitEpd;
	QIndex = QIndex + 1; //Index ++
	QCount = QCount + 1; //Count ++
}
function InitQ()
{
	for(var i=0; i<20; i++)
		BombQ[i] = 0;
	QIndex = 0;
	QCount = 0;
}

function CreateItem(location);
function Explosion(unitEpd);
function CreateFire(fireRange, direction, _x, _y);
function Boom();
function BombWayBlock(unitEpd);

function CheckBomb()
{//Check bombs' counter at map, Start of explosion. 맵의 모든 폭탄 시간 체크
	for(var i=0; i<row; i++)
	{
		for(var j=0; j<col; j++)
		{
			const unitEpd = Map.GetMapXY(i, j);
			if( unitEpd != 0 || 
				unitEpd != UnitID_Fire ||
				unitEpd != UnitID_Box ||
				unitEpd != UnitID_Wall)
			{
				if(MemoryEPD(unitEpd + 0x114/4, Exactly, 1))
				{//timer is 1(0)
					Push(unitEpd);
				}
				BombWayBlock(unitEpd);
			}
		}
	}
	var k = 0;
	while(QCount > 0) //Count > 0
	{	
		Explosion(BombQ[k]);
		k++;
		QCount = QCount - 1; // Count--
	}
	if(QIndex > 0)
	{
		Boom();
		InitQ();
	}
}

function BombWayBlock(unitEpd)
{
	if(Player.IsBombWayBlocked(unitEpd) == 0)
	{// bomb way block
		const i, j = Map.GetTileIndex(unitEpd);
		var bool = 0;
		EUDPlayerLoop()();
		const player = getcurpl();
		const px, py = Map.GetTileIndex(Player.GetPlayerEpd(player));
		if(px == i && py == j)
		{// player is on bomb
			bool = 1;
		}
		EUDEndPlayerLoop();
		if(bool == 0)
		{// no one is on bomb
			Player.SetBombWayBlock(unitEpd, 1);
			const x, y = Map.GetTileXY(i, j);
			Helpers.EUDSetLocation(loc2, x, y);
			CreateUnit(1, 129, loc2+1, Computer); //way blocker
		}
	}
}
function Boom()
{// Check explosion blocks, actual explosion 체크한 블록을 처리함. 실질적인 폭발 
	boom = 1;
	for(var i=0; i<row; i++)
	{
		for(var j=0; j<col; j++)
		{
			if(Map.GetMapXY(i, j) == UnitID_Fire)
			{
				Map.SetMapXY(i, j, 0);
				const x, y = Map.GetTileXY(i, j);
				Helpers.EUDSetLocation(loc2, x, y);
				KillUnitAt(All, '(men)', loc2+1, $Force1);
				RemoveUnitAt(All, '(any unit)', loc2+1, Computer);
				CreateUnit(1, UnitID_Fire, loc2+1, Computer);
			}
			if(Map.GetMapXY(i, j) == DeadBox)
			{
				Map.SetMapXY(i, j, 0);
				const x, y = Map.GetTileXY(i, j);
				Helpers.EUDSetLocation(loc2, x, y);
				RemoveUnitAt(All, '(men)', loc2+1, Computer);
				CreateItem(loc2);
			}
		}
	}
	KillUnit(UnitID_Fire, Computer);
	RemoveUnit(129, Computer);
	boom = 0;
}

function Explosion(unitEpd)
{// Create fire by its range 폭탄 사거리에 맞게 불 생성
	const player = Helpers.GetPlayerID(unitEpd);
	const fireRange = Player.GetRangeAtBomb(unitEpd);

	const x, y = Map.GetTileIndex(unitEpd); // 해당좌표의 unitEpd
	Map.SetMapXY(x, y, 0);  // 초기화

	const x2, y2 = Map.GetTileXY(x, y);
	Helpers.EUDSetLocation(loc2, x2, y2);
	RemoveUnitAt(1, UnitID_Bomb, loc2+1, player);

	for(var i=0; i<4; i++)
	{
		CreateFire(fireRange, i, x, y);
	}
}



function CreateFire(fireRange, direction, _x, _y)
{// 불 생성 지역에, 있는 지형/폭탄 탐지
	Map.SetMapXY(_x, _y, UnitID_Fire);
	for(var j=1; j<=fireRange; j++)
	{
		var x = _x;
		var y = _y;

		if(direction == 0) 
		{
			if(x < j) x = 0;
			else x = x - j;
		}
		if(direction == 1)
		{
			if(y < j) y = 0;
			else y = y - j;
		}
		if(direction == 2)
		{
			if(x + j > row) x = row;
			else x = x + j;
		}
		if(direction == 3)
		{
			if(y + j > col) y = col;
			else y = y + j;
		}
		
		if (Map.GetMapXY(x, y) == UnitID_Wall) return;	// Imapssible
		else if (Map.GetMapXY(x, y) == UnitID_Fire) 	// Fire
			Map.SetMapXY(x, y, UnitID_Fire);
		else if (Map.GetMapXY(x, y) == 0) 				// Empty
			Map.SetMapXY(x, y, UnitID_Fire);	
		else if (Map.GetMapXY(x, y) == UnitID_Box) 		// Breakable
		{
			Map.SetMapXY(x, y, DeadBox);
			return;
		}
		else if (Map.GetMapXY(x, y) == DeadBox) return;
		else 											// bomb (unitEpd)
		{
			const unitEpd = Map.GetMapXY(x, y);
			Push(unitEpd);
		}
	}
}

function CreateItem(location)
{
	if(Helpers.GetRandom(0,2))// 0~1
	{
		const randNum = Helpers.GetRandom(0, 9)%6; //0~8 -> 0~5
		CreateUnit(1, ItemList[randNum], location +1, Computer);
	}
}